\section{Tipos}

\begin{frame}[fragile]{Tipos}
  Usamos \texttt{:t} para ver el tipo de una expresión:
  \espacio
  \begin{lstlisting}
ghci> :t True
True :: Bool
ghci> :t 'a'
'a' :: Char
ghci> :t "Una string!"
"Una string!" :: [Char]
ghci> :t not
not :: Bool -> Bool
  \end{lstlisting}
  \note{
  Los tipos se escriben con su primera letra mayúscula.
  Haskell tiene los tipos básicos ya construidos. Existen
  \texttt{Int}, \texttt{Bool}, \texttt{Char}, \dots
  }
\end{frame}

\begin{frame}[fragile]{Tipos}
  Los tipos de Haskell son \textbf{fuertes} y \textbf{estáticos}.
  La mayor parte de los errores se detectan en compilación como errores de tipo.

  \espacio

  Además son \textbf{inferidos}, por lo que no tenemos por qué especificar el
  tipo de nuestras funciones:

  \espacio

  % No sé si este es el mejor ejemplo
  % + Sirve para introducir ahora currificación y define una función sin usar
  % + nada, yo lo veo bien.
  \begin{lstlisting}
ghci> let nand a b = not (a && b)
ghci> :t nand
nand :: Bool -> Bool -> Bool
  \end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Clases de tipos}
Las clases de tipos agrupan a tipos con la misma interfaz.
Por ejemplo, la clase \texttt{Eq}, define la función \texttt{==}.

\espacio

\begin{lstlisting}
2    :: Num a => a
pi   :: Floating a => a
(==) :: Eq a => a -> a -> Bool
\end{lstlisting}

\espacio

Las instancias de \texttt{Num} pueden sumarse y multiplicarse,
las de \texttt{Show} convertirse a \texttt{String}
y sobre las de \texttt{Integral} pueden calcularse restos modulares.
\end{frame}

\begin{frame}[fragile]{Variables de tipo}
  Haskell infiere siempre el tipo más general.
  Para ello usa \textbf{variables de tipo}, que pueden ser sustituidas:

  \espacio

  \begin{lstlisting}
 id  :: a -> a
 (+) :: Num a => a -> a -> a
 (<) :: Ord a => a -> a -> Bool
  \end{lstlisting}

  \espacio

  Las variables pueden restringirse a pertenecer a una clase.

\end{frame}

\begin{frame}[fragile]{Tipos algebraicos}
  Creamos nuevos tipos definiendo \textbf{constructores de datos}: funciones que
  devuelven valores del tipo que definimos.

  \espacio

  \begin{lstlisting}
data () = () -- Tipo None
data Bool = False | True
data Point = Point Float Float
data Triangle = Triangle Point Point Point
  \end{lstlisting}

  \note{Podemos definir tipos que dependan de otros
  o tipos con constructores sin argumentos, como \texttt{Bool}.}
\end{frame}

\begin{frame}[fragile]{Constructores de tipos}
  Los constructores de tipos son funciones sobre tipos: toman un tipo y devuelven otro.

  \espacio

  \begin{lstlisting}
"Haskell!" :: [Char]
[1,2,3,4] :: Num a => [a]
[True, False, False] :: [Bool]
[] :: [a]
Just True :: Maybe Bool
Nothing :: Maybe a
  \end{lstlisting}

\note{\texttt{[]} construye listas, y \texttt{Maybe} construye un tipo
que puede tener o no un valor.}
\end{frame}

\begin{frame}[fragile]{Constructores de tipos}
  Sus definiciones son:

  \espacio

  \begin{lstlisting}
data [a]     = [] | a:[a]
data Maybe a = Nothing | Just a
  \end{lstlisting}

  \espacio

  En las \textbf{listas}, el primer constructor es la lista vacía y
  el segundo antepone un elemento a otra lista.

  \espacio

  En el caso de \textbf{Maybe} podemos tener algo de tipo \texttt{a} (\texttt{Just a})
  o nada (\texttt{Nothing}).
\end{frame}

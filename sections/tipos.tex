\section{Tipos}

\begin{frame}[fragile]{Tipos}
  Haskell tiene los tipos básicos ya construidos. Existen
  \texttt{Int}, \texttt{Bool}, \texttt{Char}, \dots
  \begin{lstlisting}
ghci> :t True
True :: Bool
ghci> :t 'a'
'a' :: Char
ghci> :t "Una string!"
"Una string!" :: [Char]
ghci> :t not
not :: Bool -> Bool
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Tipos}
  Los tipos de Haskell son \textbf{fuertes} y \textbf{estáticos}.
  La mayor parte de los errores se detectan en compilación como errores de tipo.

  \espacio

  Además son \textbf{inferidos}, por lo que no tenemos por qué especificar el
  tipo de nuestras funciones:

  \espacio

  % No sé si este es el mejor ejemplo
  % + Sirve para introducir ahora currificación y define una función sin usar 
  % + nada, yo lo veo bien. 
  \begin{lstlisting}
ghci> let nand a b = not (a && b)
ghci> :t nand
nand :: Bool -> Bool -> Bool
  \end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Clases de tipos}
Las clases de tipos agrupan a tipos con la misma interfaz.
Por ejemplo, la clase \texttt{Eq}, define la función \texttt{==}.

\espacio

% Quito las llamadas al intérprete porque ya las hemos enseñado antes
\begin{lstlisting}
2 :: Num a => a
pi :: Floating a => a
(==) :: Eq a => a -> a -> Bool
\end{lstlisting}

\espacio

Las instancias de \texttt{Num} pueden sumarse y multiplicarse,
las de \texttt{Show} convertirse a \texttt{String}
y sobre las de \texttt{Integral} pueden calcularse restos modulares.
\end{frame}

\begin{frame}[fragile]{Variables de tipo}
  Haskell infiere siempre el tipo más general posible. Cuando
  algo puede tener varios tipos, coloca una \textbf{variable
  de tipo}, que puede ser luego sustituida.
  %% No sé cómo ni dónde contar esto.
  %% + Voy a contar que la a es una variable y puede sustituirse.
  %% + Siéntete libre de cambiarlo luego.
  \begin{lstlisting}
 id :: a -> a
 (+) :: Num a => a -> a -> a
 (<) :: Ord a => a -> a -> Bool
  \end{lstlisting}
  
  Y la variable puede verse restringida por pertenecer a una clase.
  
\end{frame}

\begin{frame}[fragile]{Tipos algebraicos}
  Creamos nuevos tipos definiendo \textbf{constructores de datos}: funciones que
  devuelven valores del tipo que definimos. % Quizás debería redactar esto de otra forma (?)

  \espacio

  \begin{lstlisting}
data () = () -- Tipo void
data Bool = False | True
data Point = Point Float Float
data Triangle = Triangle Point Point Point
  \end{lstlisting}

  \espacio

  Podemos definir tipos que dependan de otros
  o tipos con constructores sin argumentos, como \texttt{Bool}.
\end{frame}

\begin{frame}[fragile]{Constructores de tipos}
  Los constructores de tipos son funciones sobre tipos: toman un tipo y devuelven otro.

  \espacio

  Por ejemplo, \texttt{[]} construye listas, y \texttt{Maybe} construye un tipo
  que puede tener o no un valor.

  % Quito las llamadas al intérprete porque ya las hemos enseñado antes
  \begin{lstlisting}
"Haskell!" :: [Char]
[1,2,3,4] :: (Num a) => [a]
[True, False, False] :: [Bool]
[] :: [a]
Just True :: Maybe Bool
Nothing :: Maybe a
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Constructores de tipos}
  Sus definiciones son:

  \espacio

  \begin{lstlisting}
data [a]     = [] | a:[a]
data Maybe a = Nothing | Just a
  \end{lstlisting}

  \espacio

  En las \textbf{listas}, el primer constructor es la lista vacía y
  el segundo antepone un elemento a otra lista.

  \espacio

  En el caso de \textbf{Maybe} podemos tener algo de tipo \texttt{a} (\texttt{Just a})
  o nada (\texttt{Nothing}).
\end{frame}

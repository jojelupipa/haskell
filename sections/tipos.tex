\section{Tipos}

\begin{frame}[fragile]{Tipos}
  Usamos \texttt{:t} para ver el tipo de una expresión:
  \espacio
  \begin{lstlisting}
ghci> :t True
True :: Bool
ghci> :t 'a'
'a' :: Char
ghci> :t "Una string!"
"Una string!" :: [Char]
ghci> :t not
not :: Bool -> Bool
  \end{lstlisting}
  \note{
  Los tipos se escriben con su primera letra mayúscula.
  Haskell tiene los tipos básicos ya construidos. Existen
  \texttt{Int}, \texttt{Bool}, \texttt{Char}, \dots
  }
\end{frame}

\begin{frame}[fragile]{Tipos}
  Los tipos de Haskell son \textbf{fuertes} y \textbf{estáticos}.
  La mayor parte de los errores se detectan en compilación como errores de tipo.
  
  \espacio

  Además son \textbf{inferidos}, por lo que no tenemos por qué especificar el
  tipo de nuestras funciones:

  \espacio

  \begin{lstlisting}
ghci> let nand a b = not (a && b)
ghci> :t nand
nand :: Bool -> Bool -> Bool
  \end{lstlisting}
  
  \note{Más errores en compilación y menos en ejecución.
  
  Los tipos nos ayudan a documentar, a estructurar el código y
  a clarificarlo.}
\end{frame}

% \begin{frame}[fragile]{Algunos tipos}
%  Son tipos básicos y ya declarados:
%  \begin{itemize}
%   \item \texttt{Int}, entero de precisión fija.
%   \item \texttt{Integer}, entero de precisión arbitraria.
%   \item \texttt{Float}
%   \item \texttt{Bool}
%   \item \texttt{Char}
%   \item \texttt{String}
%  \end{itemize}
% 
% \end{frame}


\begin{frame}[fragile]{Clases de tipos}
Las clases de tipos agrupan a tipos con la misma interfaz.
Por ejemplo, la clase \texttt{Eq}, agrupa a los que tienen
definida la función \texttt{(==)}.

\espacio

\begin{lstlisting}
2    :: Num a => a
pi   :: Floating a => a
(==) :: Eq a => a -> a -> Bool
\end{lstlisting}

\espacio

Las instancias de \texttt{Num} pueden sumarse y multiplicarse,
las de \texttt{Show} convertirse a \texttt{String}
y sobre las de \texttt{Integral} pueden calcularse restos modulares.

\note{
  No se debe confundir la doble flecha, que está siempre al principio e introduce
condiciones, con la flecha simple que sirve para escribir funciones de un tipo a
otro.
}
\end{frame}

\begin{frame}[fragile]{Variables de tipo}
  Haskell infiere siempre el tipo más general.
  Para ello usa \textbf{variables de tipo}, que pueden ser sustituidas:

  \espacio

  \begin{lstlisting}
 id  :: a -> a
 (+) :: Num a => a -> a -> a
 (<) :: Ord a => a -> a -> Bool
  \end{lstlisting}

  \espacio

  Las variables pueden restringirse a pertenecer a una clase.

\note{
\begin{itemize}
  \item El espacio de nombres de las variables de tipo es independiente en cada declaración.
  \item Por convención se utilizan nombres cortos para las variables
  \item La clase de tipo \texttt{Ord} incluye tipos con relaciones de orden definidas.
\end{itemize}
}

\end{frame}

\begin{frame}[fragile]{Tipos algebraicos}
  Creamos nuevos tipos definiendo \textbf{constructores de datos}: funciones que
  devuelven valores del tipo que definimos.

  \espacio

  \begin{lstlisting}
data () = () -- Tipo None
data Bool = False | True
data Point = Point Float Float
data Triangle = Triangle Point Point Point
  \end{lstlisting}

\note{
  Los constructores se separan con \texttt{|}.

  Podemos definir tipos que dependan de otros
   o tipos con constructores sin argumentos, como \texttt{Bool}.
}
\end{frame}

\begin{frame}[fragile]{Constructores de tipos}
  Los \textbf{constructores de tipos} son funciones sobre tipos:
   toman un tipo y devuelven otro.

  \espacio

  \begin{lstlisting}
"Haskell!" :: [Char]
[1,2,3,4] :: Num a => [a]
[True, False, False] :: [Bool]
[] :: [a]
Just True :: Maybe Bool
Nothing :: Maybe a
  \end{lstlisting}

\note{

\texttt{[]} construye listas, y \texttt{Maybe} construye un tipo
que puede tener o no un valor. \texttt{->} es el constructor de funciones.

Aunque es posible, no es recomendable aplicar restricciones de clase a los tipos
de entrada.
}
\end{frame}

\begin{frame}[fragile]{Constructores de tipos}
  Sus definiciones son:

  \espacio

  \begin{lstlisting}
data [a]     = [] | a:[a]
data Maybe a = Nothing | Just a
  \end{lstlisting}

  \espacio

  En las \textbf{listas}, el primer constructor es la lista vacía y
  el segundo antepone un elemento a otra lista.

  \espacio

  En el caso de \textbf{Maybe} podemos tener algo de tipo \texttt{a} (\texttt{Just a})
  o nada (\texttt{Nothing}).

\note{
  Las listas son flujos en otros lenguajes. Son puramente funcionales y perezosas.
}
\end{frame}

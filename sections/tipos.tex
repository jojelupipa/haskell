\section{Tipos}

\begin{frame}[fragile]{Tipos}
  Haskell tiene los tipos básicos ya construidos. Existen
  \texttt{Int}, \texttt{Bool}, \texttt{Char}, \dots
  \begin{lstlisting}
ghci> :t True
True :: Bool
ghci> :t 'a'
'a' :: Char
ghci> :t "Una string!"
"Una string!" :: [Char]
ghci> :t not
not :: Bool -> Bool
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Tipos}
  Los tipos de Haskell son \textbf{fuertes} y \textbf{estáticos}.
  La mayor parte de los errores se detectan en compilación como errores de tipo.

  \espacio

  Además son \textbf{inferidos}, por lo que no tenemos por qué especificar el
  tipo de nuestras funciones:

  \espacio

  % No sé si este es el mejor ejemplo
  \begin{lstlisting}
ghci> let nand a b = not (a && b)
ghci> :t nand
nand :: Bool -> Bool -> Bool
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Clases de tipos}
Las clases de tipos agrupan a tipos con la misma interfaz.
Por ejemplo, la clase \texttt{Eq}, define la función \texttt{==}.

\espacio

\begin{lstlisting}
ghci> :t 2
2 :: Num a => a
ghci> :t pi
pi :: Floating a => a
ghci> :t (==)
(==) :: Eq a => a -> a -> Bool
\end{lstlisting}

\espacio

Las instancias de \texttt{Num} pueden sumarse y multiplicarse,
las de \texttt{Show} convertirse a \texttt{String}
y sobre las de \texttt{Integral} pueden calcularse restos modulares.
\end{frame}

\begin{frame}[fragile]{Variables de tipo}
  Haskell infiere siempre el tipo más general posible.
  %% No sé cómo ni dónde contar esto.
\end{frame}

\begin{frame}[fragile]{Tipos algebraicos}
  Creamos nuevos tipos definiendo \textbf{constructores de datos}: funciones que
  devuelven valores del tipo que definimos. % Quizás debería redactar esto de otra forma (?)

  Utilizamos para ello \texttt{data}, separando los constructores con \texttt{|}

  \espacio

  \begin{lstlisting}
data () = () -- Tipo void
data Bool = False | True
data Point = Cart Float Float | Polar Float Float
data Triangle = Triangle Point Point Point
  \end{lstlisting}

  \espacio

  Como vemos, podemos definir tipos a partir de otros, y tener constructores que
  no tomen argumentos, como \texttt{False} o \texttt{True}.
\end{frame}

\begin{frame}[fragile]{Constructores de tipos}
  Los constructores de tipos son funciones sobre tipos: toman un tipo y devuelven otro.

  \espacio

  Por ejemplo, \texttt{[]} construye listas, y \texttt{Maybe} construye un tipo
  que puede tener o no un valor.

  \begin{lstlisting}
ghci> :t "Haskell!"
"Haskell!" :: [Char]
ghci> :t [1,2,3,4]
[1,2,3,4] :: (Num a) => [a]
ghci> :t [True, False, False]
[True, False, False] :: [Bool]
ghci> :t []
[] :: [a]
ghci> :t Just True
Just True :: Maybe Bool
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Constructores de tipos}
  Sus definiciones son:

  \espacio

  \begin{lstlisting}
data [a]     = [] | a:[a]
data Maybe a = Nothing | Just a
  \end{lstlisting}

  \espacio

  En las \textbf{listas}, el primer constructor es la lista vacía y
  el segundo antepone un elemento a otra lista.

  \espacio

  En el caso de \textbf{Maybe} podemos tener algo de tipo \texttt{a} (\texttt{Just a})
  o nada (\texttt{Nothing}).
\end{frame}

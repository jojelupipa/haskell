\section{Haskell}

\begin{frame}[fragile]{Instalando Haskell Platform}

 \begin{columns}
  \column{.7\textwidth}
  \texttt{haskell-platform} contiene el compilador, depurador y otras utilidades.
  También podemos instalar \texttt{ghc}:
  \espacio
  \begin{lstlisting}[language=bash]
apt-get install haskell-platform
  \end{lstlisting}
  \espacio
  Ambos traen un gestor de librerías: \texttt{cabal}.
  \column{.3\textwidth}
  \haskelllogo[rounded corners=2pt]
  \center{\scriptsize \textit {Haskell logo}}
 \end{columns}
  
  \note{
    \begin{itemize}
      \item ghc: (Glorious) Glasgow Haskell Compiler.
      \item Linter: \texttt{hlint}.
      \item El paquete está disponible al menos en distribuciones Debian, Fedora y Arch.
    \end{itemize}
  }
\end{frame}


\begin{frame}{El intérprete: GHCi}
  GHC incluye GHCi como intérprete. Permite los siguientes comandos:
  \espacio
  \begin{itemize}
    \item \texttt{:q} \qquad  Quitar
    \item \texttt{:l} \qquad  Cargar módulo
    \item \texttt{:r} \qquad  Recargar módulos
    \item \texttt{:t} \qquad  Consultar tipos
  \end{itemize}

\note{
Haskell permite operaciones aritméticas básicas, y operaciones con
cadenas, listas o booleanos.
\begin{itemize}
  \item \texttt{:set +t} para mostrar el tipo por defecto.
  \item \texttt{:set +m} para permitir entrada de varias líneas.
\end{itemize}
}
\end{frame}

\begin{frame}[fragile]{El intérprete: GHCi}
 Las funciones se llaman escribiendo su nombre, un espacio y sus parámetros, separados por espacios:
\espacio
  \begin{lstlisting}
ghci> 3 + 4
7
ghci> (+) 2 9
11
ghci> succ 27
28
ghci> max 23 34
34
  \end{lstlisting}

\note{
\begin{itemize}
  \item Estamos usando \textbf{notación polaca}.
  \item Para escribir una función infija de forma prefija se pone entre paréntesis.
  \item Para escribir una función prefija de forma infija se pone entre acentos graves.
\end{itemize}
}
\end{frame}



\begin{frame}[fragile]{Puro: sin efectos secundarios}

  \begin{columns}
    \column{.7\textwidth}
    Las funciones no tienen \textit{efectos secundarios}.
    No alteran el mundo ni cambian el valor de los argumentos.
    \espacio
  \begin{lstlisting}[language=C++]
int n = 0;
int next() { return n++; }
next(); // n = 1
  \end{lstlisting}
  \espacio
  Los objetos son inmutables. Son \texttt{thread-safe}.
  \column{.3\textwidth}
    \includegraphics[width=\textwidth]{./images/xkcd-haskell.png}
    \center{\scriptsize \textit xkcd: \href{http://xkcd.com/1312}{Haskell}}
  \end{columns}

  \note{
  \begin{itemize}
    \item Ejemplo de \url{http://programmers.stackexchange.com/questions/40297}.
    \item Una función puede cambiar variables o escribir por pantalla.
    Eso hace que el orden de llamada importe.
  \end{itemize}
  }
\end{frame}

\begin{frame}[fragile]{Puro: transparencia referencial}
  Que las expresiones de Haskell sean referencialmente transparentes
  quiere decir:
  \begin{itemize}
   \item Todas las variables son \textbf{inmutables}.
   \item Las funciones son \textbf{deterministas}.
   \item Lo definido puede ser sustituido por su definición.
  \end{itemize}

  \espacio

  Y esto nos permite:
  \begin{itemize}
   \item Razonar algebraicamente: \texttt{f = g } $\Rightarrow$ \texttt{ f a = g a}.
   \item Paralelizar fácilmente: \texttt{f `par` g}, sin afectarse.
  \end{itemize}


  \note{
  \begin{itemize}
   \item \textbf{Inmutables}: no cambian de valor en ejecución.
   \item \textbf{Deterministas}: devuelven lo mismo si se les pasan los mismos argumentos.
  \item \textbf{Par}: En \texttt{Control.Parallel} \textit{The expression (x `par` y) sparks the evaluation of x (to weak head 
  normal form) and returns y.} \url{https://downloads.haskell.org/~ghc/7.0-latest/docs/html/users_guide/lang-parallel.html#id3208592}
  \end{itemize}
  }

\end{frame}

\begin{frame}[fragile]{Funcional: evaluación}
  La programación se centra en \textbf{evaluar expresiones} en
  lugar de \textbf{ejecutar instrucciones}.
  
  \note{La diferencia es que nosotros no explicitamos al compilador
  cómo deben ser evaluadas estas expresiones. Simplemente indicamos lo 
  que queremos obtener. En la programación imperativa solemos describir
  el proceso para obtenerlo, y no lo que queremos obtener.
  
  \espacio
  Esta libertad permite al compilador evaluar las expresiones en el 
  orden que quiera.}
\end{frame}

\begin{frame}[fragile]{Funcional: las funciones como objetos}
 Las funciones son objetos de \textit{primera clase}. Pueden ser devueltos
 por funciones y pueden pasarse como argumentos.

 \begin{lstlisting}
 duplica lista = map (\ x -> 2*x) lista
 \end{lstlisting}

 \espacio
 Esto ayuda a reutilizar código.
 \begin{lstlisting}[language=C++]
int duplica(int a);
int incrementa(int a);
vector<int> duplica_vector(vector<int> v);
vector<int> incrementa_vector(vector<int> v);
 \end{lstlisting}
 \note{Las dos últimas funciones sólo se diferencian en la función
 que aplican sobre las componentes, eso podría ser un argumento
 a una función \texttt{aplica\_vector} más general.}

 \note{
  Puede notarse la necesidad de separar dos partes:
   \begin{itemize}
    \item La función en sí.
    \item El aplicarla sobre un vector.
   \end{itemize}
  }
  
  \note{
    Aunque el resto de la sintaxis no es importante, hay que 
    notar la función lambda. Una función anónima nos ahorra
    definirla y ponerle un nombre antes de usarla.
  }
\end{frame}

\begin{frame}[fragile]{Funcional: abstracción}
  El ser funcional facilita factorizar el código. Cada
  pieza debería aparecer sólo una vez en su forma más
  general posible. Esto se consigue con:

  \begin{itemize}
   \item \textbf{Polimorfismo}, abstraer el tipo.
   \item \textbf{Clases de tipos}, unifican propiedades de varios tipos.
   \item \textbf{Funciones de alto nivel}, abstraen otras funciones.
  \end{itemize}

  \note{
    \begin{itemize}
    \item Se facilita abstraer y reutilizar el código. Se puede hacer en otros 
    lenguajes con más dificultad
    \item El lenguaje va a ser polimórfico, habrá clases de tipos que nos dejan tratar varios como si fueran el
    mismo. Suple necesidades de las interfaces y la herencia en el paradigma de
    objetos.
    \end{itemize}
  }

\end{frame}



\section{Más}

\begin{frame}[fragile]{Hoogle}
  Cuando no encontramos una función con el tipo que queremos, podemos
  buscarla por tipo en Hoogle:
  
  \begin{center}
  \includegraphics[scale=0.35]{./images/hoogle.png}
  \end{center}
\end{frame}


\begin{frame}[fragile]{Curry-Howard}
  Como las funciones no tienen efectos secundarios, podemos razonar la
  corrección del código por inducción:

  \begin{lstlisting}[language=haskell]
qsort []     = []
qsort (x:xs) = qsort [y | y<-xs, y<=x]
            ++ [x]
            ++ qsort [y | y<-xs, y>x]
  \end{lstlisting}

  \textbf{Demostración:} \textit{Quicksort} funciona porque:
  \begin{itemize}
   \item ordena correctamente una lista vacía.
   \item la lista creada mantiene el orden entre las tres partes
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Curry-Howard}
  \textbf{Idris}, construido encima de Haskell, demuestra que los
  programas son correctos.
  
  \begin{center}
  \includegraphics[scale=0.28]{./images/idris.png}
  \end{center}
\end{frame}

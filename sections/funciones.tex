\section{Funciones}

\begin{frame}[fragile]{Reconocimiento de patrones}
  Para definir una función sobre un tipo, definimos su comportamiento para cada
  constructor de datos del tipo:
  \begin{lstlisting}
neg :: Bool -> Bool
neg False = True
neg True  = False
  \end{lstlisting}

  \espacio

  Podemos sustituir argumentos del constructor por variables:
  \begin{lstlisting}
factorial :: Integral a => a -> a
factorial 0 = 1
factorial n = n * factorial (n - 1)
  \end{lstlisting}

\note{
Cada entero es un constructor de tipos de \texttt{Int}.
Las ecuaciones se evalúan en el orden en que aparecen, cambiando el orden de la
segunda definición dejaría de funcionar.
}
\end{frame}

\begin{frame}[fragile]{Recursividad}
  El tipo lista y las definiciones recursivas son la base de los programas de Haskell.
  Para calcular la \textbf{longitud de una lista}, definimos la función para sus dos
  constructores:

  \espacio

  \begin{lstlisting}
len :: Num a => [t] -> a
len []     = 0
len (_:xs) = 1 + len xs
  \end{lstlisting}

  \note{
  Normalmente la lista vacía nos proporciona el caso base y \texttt{:} la ecuación recursiva.

  No es la versión más eficiente porque no emplea recursión de cola;
  necesitaría un parámetro acumulador.

  Ponemos el segundo constructor entre paréntesis para distinguir de una función
  que tomara 3 argumentos: _, : , xs.
  }
\end{frame}

\begin{frame}[fragile]{Currificación}
  ¿Por qué \texttt{(+)} es de tipo \texttt{\alert{a -> a} -> a}
  y no \texttt{\alert{(a,a)} -> a}?

  \espacio

  Esto nos permite aplicar parcialmente una función. El tipo hay que leerlo realmente como
  \texttt{a -> (a -> a)}, es decir, al darle un número nos devuelve otra función:
    \begin{lstlisting}
(+)    :: Num a => a -> a -> a
(+3)   :: Num a => a -> a
(+3) 5 :: Num a => a
  \end{lstlisting}
  Es lo mismo decir \texttt{(+3) 5} que \texttt{(+) 3 5}.

\note{
Existen las funciones \texttt{curry} y \texttt{uncurry}.
}
\end{frame}


\begin{frame}[fragile]{Funciones de orden superior}
  Son funciones que toman funciones como argumento.

  \espacio

  \texttt{map} toma una función y devuelve su versión sobre listas:
  \begin{lstlisting}
map :: (a -> b) -> ([a] -> [b])
  \end{lstlisting}
  \ejemplo{map not [True, True, False]}

  \espacio
  
  \texttt{foldr} toma una función y un acumulador
  y aplica los elementos de la lista contra el acumulador.
  \begin{lstlisting}
foldr :: (a -> b -> b) -> b -> [a] -> b
  \end{lstlisting}
  \ejemplo{foldr (*) 1 [2,3,5,7]}

\note{\texttt{map} aplica la función a cada elemento de la lista.
      \texttt{map f = foldr ((:) . f) []}}
\end{frame}

\begin{frame}[fragile]{Especialización}
  A partir de estas podemos crear funciones básicas:

  \espacio

  \begin{lstlisting}
 negation  = map not
 lowerText = map toLower
 sum       = foldr (+) 0
 product   = foldr (*) 1
 concat    = foldr (++) []
 and       = foldr (&&) True
  \end{lstlisting}
  \espacio
  \ejemplo{lowerText ''aBcDEfG''}

  \note{Podemos escribirlas sin todos los argumentos por la currificación.}
\end{frame}

\section{Funciones}

\begin{frame}[fragile]{Reconocimiento de patrones}
  Para definir una función sobre un tipo, definimos su comportamiento para cada
  constructor de datos del tipo:
  \begin{lstlisting}
neg :: Bool -> Bool
neg False = True
neg True  = False
  \end{lstlisting}

  \espacio

  Podemos sustituir argumentos del constructor por variables:
  \begin{lstlisting}
factorial :: Integral a => a -> a
factorial 0 = 1
factorial n = n * factorial (n - 1)
  \end{lstlisting}

\note{
Cada entero es un constructor de tipos de \texttt{Int}.
Las ecuaciones se evalúan en el orden en que aparecen, cambiando el orden de la
segunda definición dejaría de funcionar.
}
\end{frame}

\begin{frame}[fragile]{Recursividad}

  \begin{columns}
  \column{.5\textwidth}
  Para calcular la \textbf{longitud de una lista}, definimos la función para sus dos
  constructores:

  \espacio
  \begin{lstlisting}
len :: Num a => [t] -> a
len []     = 0
len (_:xs) = 1 + len xs
  \end{lstlisting}
\column{.5\textwidth}
\texttt{len [1,2,3]}:
  \begin{lstlisting}
len (1:2:3:[])
1 + len (2:3:[])
1 + 1 + len (3:[])
1 + 1 + 1 + len []
1 + 1 + 1 + 0
1 + 1 + 1
1 + 2
3
  \end{lstlisting}
\end{columns}
\note{
  \begin{itemize}
    \item El tipo lista y las definiciones recursivas son la base de los programas de Haskell.
    \item Normalmente \texttt{[]} es el caso base y \texttt{:} la ecuación recursiva.
    \item No es la versión más eficiente porque no emplea recursión de cola;
    necesitaría un parámetro acumulador. Además da lugar a space leak.
    \item Ponemos el segundo constructor entre paréntesis para distinguir de una función
    que tomara 3 argumentos: \_, \: , xs.
  \end{itemize}
}
\end{frame}

\begin{frame}[fragile]{Currificación}
  ¿Por qué \texttt{(+)} es de tipo \texttt{\alert{a -> a} -> a}
  y no \texttt{\alert{(a,a)} -> a}?

  \espacio

  Esto nos permite aplicar parcialmente una función. El tipo hay que leerlo realmente como
  \texttt{a -> (a -> a)}, es decir, al darle un número nos devuelve otra función:
    \begin{lstlisting}
(+)    :: Num a => a -> a -> a
(+3)   :: Num a => a -> a
(+3) 5 :: Num a => a
  \end{lstlisting}
  Es lo mismo decir \texttt{(+3) 5} que \texttt{(+) 3 5}.

\note{
Existen las funciones \texttt{curry} y \texttt{uncurry}.
}
\end{frame}


\begin{frame}[fragile]{Funciones de orden superior}
\hypertarget{funcionesOrdenSup}{}

  \texttt{map} toma una función y devuelve su versión sobre listas:
  \begin{lstlisting}
map :: (a -> b) -> ([a] -> [b])
  \end{lstlisting}
  \ejemplo{map not [True, True, False]}

  \espacio

  \texttt{foldr} toma una función, un acumulador y una lista
  y aplica los elementos de la lista contra el acumulador.
  \begin{lstlisting}
foldr :: (a -> b -> b) -> b -> [a] -> b
  \end{lstlisting}
  \ejemplo{foldr (*) 1 [2,3,5,7]}

\hfill\hyperlink{definiciones}{\beamergotobutton{Definiciones}}

\note{%
\begin{itemize}
\item Son funciones que toman funciones como argumento.
\item \texttt{map} aplica la función a cada elemento de la lista.
\item \texttt{map f = foldr ((:) . f) []}
\end{itemize}
}
\end{frame}

\begin{frame}[fragile]{Especialización}
  A partir de estas podemos crear funciones básicas:

  \espacio

  \begin{lstlisting}
 negation  = map not
 lowerText = map toLower
 sum       = foldr (+) 0
 product   = foldr (*) 1
 concat    = foldr (++) []
 and       = foldr (&&) True
  \end{lstlisting}
  \espacio
  \ejemplo{lowerText ''aBcDEfG''}

  \note{Podemos escribirlas sin todos los argumentos por la currificación.}
\end{frame}

\begin{frame}[fragile]{Evaluación perezosa}
  Haskell retrasa la evaluación de una expresión todo lo posible:
  \begin{lstlisting}
head [1..10**9]     -- Sólo evalua 1
  \end{lstlisting}

  \espacio

  Esto permite la modularización del código:
  \begin{lstlisting}
min :: Ord a => [a] -> a
min = head . sort
  \end{lstlisting}
\espacio
  Y el uso de estructuras infinitas:
  \begin{lstlisting}
unos      = 1:unos
diezDoses = take 10 (map (+1) unos)
  \end{lstlisting}
\note{
\begin{itemize}
  \item Haskell comprueba el tipo de las expresiones (evaluando la WHNF) por lo que
\texttt{length [1, 1/0, 2]} es válido pero \texttt{length [1, ''adsf'', 2]} no.
  \item min es O(n) + O(n/2) + O(n/4) + ... = O(n)
\end{itemize}
}
\end{frame}

\section{Funciones}

\begin{frame}[fragile]{Reconocimiento de patrones}
  Para definir una función sobre un tipo, definimos su comportamiento para cada
  constructor de datos del tipo:

  \espacio

  \begin{lstlisting}
neg :: Bool -> Bool
neg False = True
neg True  = False
  \end{lstlisting}

  \espacio
  
  Podemos utilizar variables para sustituir cualquier argumento del constructor:

  \espacio

  \begin{lstlisting}
suma (Point a b) (Point c d) = Point (a+c) (b+d)
opuesto (Point a b) = Point (-a) (-b)
resta a b = suma a (opuesto b)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Recursividad}
  El tipo lista y las definiciones recursivas son la base de los programas de Haskell.
  Por ejemplo, para calcular la \textbf{longitud de una lista}, definimos la función
  \texttt{len} para sus dos constructores:

  \espacio

  \begin{lstlisting}
len []     = 0
len (_:xs) = 1 + len xs
  \end{lstlisting}

    \espacio

  El primer constructor nos proporciona el caso base y el segundo la ecuación recursiva.
\end{frame}

\begin{frame}[fragile]{Currificación}
  ¿Por qué el tipo de \texttt{(+)}, por ejemplo, es \texttt{(Num a) => a -> a -> a} en lugar de
  ser \texttt{(Num a) => (a,a) -> a}?
  \\~\\
  Eso nos permite aplicar parcialmente una función. El tipo hay que leerlo realmente como
  \texttt{a -> (a -> a)}, es decir, al darle un número nos devuelve otra función:
    \begin{lstlisting}
(+)  :: Num a => a -> a -> a
(+3) :: Num a => a -> a
  \end{lstlisting}
  Es lo mismo decir \texttt{(+3) 5} que \texttt{(+) 3 5}.
\end{frame}


\begin{frame}[fragile]{Funciones de orden superior}
  Son las funciones que toman funciones como argumento.
  \\~\\
  \texttt{map} toma una función y devuelve su versión sobre listas,
  elemento a elemento:
  \begin{lstlisting}
map :: (a -> b) -> ([a] -> [b])
  \end{lstlisting}
  Ejemplo: \texttt{map not [True, True, False]}
  \\~\\
  \textt{foldr} toma una función y un acumulador y aplica todos los elementos
  de la lista contra el acumulador.
  \begin{lstlisting}
foldr :: (a -> a -> a) -> a -> [a] -> a
  \end{lstlisting}
  Ejemplo: \texttt{foldr (*) 1 [2,3,5,7]}
\end{frame}

\begin{frame}[fragile]{Especialización}
  Ahora, a partir de funciones tan generales, podemos crear las funciones básicas
  trivialmente
\end{frame}